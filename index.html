<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>PokeRogue Editor</title>
        <meta name="robots" content="index, follow" />
        <meta name="author" content="Your Name" />
        <meta
            name="description"
            content="A simple online AES encryption/decryption tool."
        />
        <meta
            name="keywords"
            content="cryptography, encryption, decryption, AES, AES 256, Rijndael"
        />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, minimum-scale=1.0"
        />
        <style>
            @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap");

            :root {
                --bg-color: #fdfdfd;
                --surface-1: #f0d6d6;
                --primary: #ff2058;
                --secondary: #00e0ff;
                --text: #000000;
                --border: #000000;
                --radius: 12px;
                --shadow-offset: 4px;
                --shadow-colour: rgba(0, 0, 0, 0.9);
                --master: #ffcf00;
            }

            * {
                box-sizing: border-box;
                margin: 0;
            }

            html,
            body {
                height: 100%;
            }

            body {
                font-family: "Inter", Arial, sans-serif;
                background: var(--bg-color);
                color: var(--text);
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 2rem;
                line-height: 1.4;
            }

            form {
                background: var(--surface-1);
                padding: 2.5rem 3rem;
                border: 3px solid var(--border);
                border-radius: var(--radius);
                box-shadow: var(--shadow-offset) var(--shadow-offset) 0 0
                    var(--shadow-colour);
                max-width: 480px;
                width: 100%;
            }

            h1 {
                font-size: 1.4rem;
                text-transform: uppercase;
                letter-spacing: 1px;
                margin-bottom: 0.25rem;
            }

            p {
                margin-bottom: 1.75rem;
            }

            fieldset {
                border: none;
                padding: 0;
                display: flex;
                flex-direction: column;
                gap: 1rem;
            }

            label {
                font-weight: 600;
            }

            input[type="file"] {
                width: 100%;
                border: 3px dashed var(--border);
                padding: 1.25rem;
                border-radius: var(--radius);
                background: #ffffff;
                cursor: pointer;
                transition: background 0.15s ease-in-out;
            }

            input[type="file"]:hover {
                background: var(--secondary);
            }

            button {
                appearance: none;
                font-size: 1rem;
                font-weight: 700;
                padding: 0.8rem 1rem;
                border: 3px solid var(--border);
                border-radius: var(--radius);
                background: var(--primary);
                color: var(--text);
                cursor: pointer;
                box-shadow: var(--shadow-offset) var(--shadow-offset) 0 0
                    var(--shadow-colour);
                transition: transform 0.1s ease-in-out;
            }

            button.btn-secondary {
                background: var(--secondary);
            }

            button.btn-heal {
                background: #b6ff00;
            }

            button.btn-master {
                background: var(--master);
            }

            button:active {
                transform: translate(
                    var(--shadow-offset),
                    var(--shadow-offset)
                );
                box-shadow: 0 0 0 0 var(--shadow-colour);
            }

            button:focus-visible,
            input[type="file"]:focus-visible {
                outline: 3px dotted var(--border);
                outline-offset: 3px;
            }

            @media (max-width: 600px) {
                form {
                    padding: 1.75rem 1.5rem;
                }
            }
        </style>
    </head>
    <body>
        <form id="form" action="">
            <h1>PokeRogue Save Converter</h1>
            <fieldset id="input">
                <label for="file">Select .json or .prsv file:</label>
                <input type="file" id="file" accept=".json, .prsv" required />
                <button type="button" id="encryptBtn">Encrypt and Download</button>
                <button type="button" id="decryptBtn" class="btn-secondary">Decrypt and Download</button>
                <button type="button" id="healBtn" class="btn-heal">Heal Up</button>
                <button type="button" id="addMasterBtn" class="btn-master">+1 Master Ball</button>
            </fieldset>
        </form>
        <script src="js/cryptography-js.min.js"></script>
        <script>
            const AES_KEY = "x0i2O7WRiANTqPmZ";

            window.onload = function () {
                const fileInput = document.getElementById("file");

                document
                    .getElementById("decryptBtn")
                    .addEventListener("click", function () {
                        handleDecrypt(fileInput.files[0]);
                    });

                document
                    .getElementById("encryptBtn")
                    .addEventListener("click", function () {
                        handleEncrypt(fileInput.files[0]);
                    });

                document
                    .getElementById("healBtn")
                    .addEventListener("click", function () {
                        handleHeal(fileInput.files[0]);
                    });

                document
                    .getElementById("addMasterBtn")
                    .addEventListener("click", function () {
                        handleAddMaster(fileInput.files[0]);
                    });
            };

            function downloadBlob(blob, filename) {
                const link = document.createElement("a");
                link.href = window.URL.createObjectURL(blob);
                link.download = filename;
                link.click();
            }

            function showError(msg) {
                alert(msg);
                console.error(msg);
            }

            function decryptText(ciphertext) {
                const decrypted = CryptoJS.AES.decrypt(ciphertext, AES_KEY);
                return decrypted.toString(CryptoJS.enc.Utf8);
            }

            function encryptText(plaintext) {
                return CryptoJS.AES.encrypt(
                    CryptoJS.enc.Latin1.parse(plaintext),
                    AES_KEY
                ).toString();
            }

            function handleDecrypt(file) {
                if (!file) {
                    showError("Please select a file.");
                    return;
                }

                const reader = new FileReader();
                reader.onload = function (event) {
                    try {
                        const plaintext = decryptText(event.target.result);
                        const jsonContent = JSON.parse(plaintext);
                        const blob = new Blob([
                            JSON.stringify(jsonContent, null, 2),
                        ], {
                            type: "application/json",
                        });

                        const filename = file.name.startsWith("data")
                            ? "data_Guest.json"
                            : file.name.startsWith("sessionData")
                            ? "sessionData_Guest.json"
                            : "decrypted_data.json";

                        downloadBlob(blob, filename);
                    } catch (e) {
                        showError("Error: Failed to decrypt or parse JSON.");
                    }
                };

                reader.readAsText(file);
            }

            function handleEncrypt(file) {
                if (!file) {
                    showError("Please select a file.");
                    return;
                }

                const reader = new FileReader();
                reader.onload = function (event) {
                    try {
                        const ciphertext = encryptText(event.target.result);
                        const blob = new Blob([ciphertext], {
                            type: "application/octet-stream",
                        });

                        const extension = file.name.endsWith(".json")
                            ? "prsv"
                            : "json";
                        const filename = file.name.replace(
                            /\.[^/.]+$/,
                            `.${extension}`
                        );

                        downloadBlob(blob, filename);
                    } catch (e) {
                        showError("Error: Failed to encrypt.");
                    }
                };

                reader.readAsBinaryString(file);
            }

            function handleHeal(file) {
                if (!file) {
                    showError("Please select a file.");
                    return;
                }

                const reader = new FileReader();
                reader.onload = function (event) {
                    try {
                        let jsonContent;

                        if (file.name.endsWith(".prsv")) {
                            const plaintext = decryptText(event.target.result);
                            jsonContent = JSON.parse(plaintext);
                        } else {
                            jsonContent = JSON.parse(event.target.result);
                        }

                        if (Array.isArray(jsonContent.party)) {
                            jsonContent.party.forEach((p) => {
                                if (Array.isArray(p.stats) && p.stats.length) {
                                    p.hp = p.stats[0];
                                }
                                p.status = null;
                            });
                        }

                        const updatedPlain = JSON.stringify(jsonContent);
                        const newCipher = encryptText(updatedPlain);
                        const blob = new Blob([newCipher], {
                            type: "application/octet-stream",
                        });

                        const baseName = file.name.replace(/\.[^/.]+$/, "");
                        const filename = `${baseName}_HealUp.prsv`;

                        downloadBlob(blob, filename);
                    } catch (e) {
                        showError("Error: Failed to process Heal Up operation.");
                    }
                };

                reader.readAsText(file);
            }

            function handleAddMaster(file) {
                if (!file) {
                    showError("Please select a file.");
                    return;
                }

                const reader = new FileReader();
                reader.onload = function (event) {
                    try {
                        let jsonContent;

                        if (file.name.endsWith(".prsv")) {
                            const plaintext = decryptText(event.target.result);
                            jsonContent = JSON.parse(plaintext);
                        } else {
                            jsonContent = JSON.parse(event.target.result);
                        }

                        if (!jsonContent.pokeballCounts) {
                            jsonContent.pokeballCounts = {};
                        }
                        if (!jsonContent.pokeballCounts["4"]) {
                            jsonContent.pokeballCounts["4"] = 0;
                        }

                        jsonContent.pokeballCounts["4"] += 1;

                        const updatedPlain = JSON.stringify(jsonContent);
                        const newCipher = encryptText(updatedPlain);
                        const blob = new Blob([newCipher], {
                            type: "application/octet-stream",
                        });

                        const baseName = file.name.replace(/\.[^/.]+$/, "");
                        const filename = `${baseName}_PlusMaster.prsv`;

                        downloadBlob(blob, filename);
                    } catch (e) {
                        showError("Error: Failed to add Master Ball.");
                    }
                };

                reader.readAsText(file);
            }
        </script>
    </body>
</html>
